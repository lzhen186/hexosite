---
title: 多线程和异步专题
date: 2021-12-21T08:58:41.072Z
---
1. 线程、进程和多线程
2. 多线程

   1. 继承Thread类

      ```java
      public class MyThread extends Thread {

          @Override
          public void run(){
              for (int i = 0; i < 200; i++) {
                  System.out.println("线程执行....");
              }
          }

          public static void main(String[] args) {
              MyThread myThread = new MyThread(); 
              myThread.start(); //一个线程启动

              for (int i = 0; i < 500; i++) {
                  System.out.println("主线程执行，，，，");
              }
          }

      }
      ```
   2. 实现Runabble接口

      ```java
      public class MyThread3 implements Runnable {

          @Override
          public void run() {
              for (int i = 0; i < 200; i++) {
                  System.out.println("线程。。。。。。");
              }
          }

          public static void main(String[] args) {

              MyThread3 thread3 = new MyThread3();

              new Thread(thread3).start();

              for (int i = 0; i < 200; i++) {
                  System.out.println("主子线程....");
              }
          }
      }
      ```

      龟兔赛跑

      ```java
      public class Race implements Runnable {
          private String winer= null;
          @Override
          public void run() {
              for (int i = 0; i <= 100; i++) {
                  if (Thread.currentThread().getName().equals("兔子") &&  i%10==0){
                      try {
                          Thread.sleep(1);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }

                  if(i>=100){
                      winer = Thread.currentThread().getName();
                      System.out.println(winer+"赢了");
                  }
                  if(winer!=null){
                      break;
                  }
                  System.out.println(Thread.currentThread().getName()+"==>跑了"+i);
              }
          }


          public static void main(String[] args) {
              Race race = new Race();

              new Thread(race,"兔子").start();
              new Thread(race,"乌龟").start();
          }
      }
      ```
   3. 实现Callable接口

      ```java
      public class CallableTest implements Callable<Boolean> {
          @Override
          public Boolean call() throws Exception {
              System.out.println(Thread.currentThread().getName());
              return true;
          }

          public static void main(String[] args) throws ExecutionException, InterruptedException {
              CallableTest callableTest = new CallableTest();

              ExecutorService service = Executors.newFixedThreadPool(1);
              Future<Boolean> submit = service.submit(callableTest);
              Boolean aBoolean = submit.get();
              System.out.println(aBoolean);
              service.shutdownNow();
          }
      }
      ```
   4. 静态代理模式和lamda

      ```java
      public class StaticProxy {

          public static void main(String[] args) {
             //静态代理
              Me me = new Me();
              DaiGou daiGou = new DaiGou(me);
              daiGou.shopping();

            //测速lamda
              ShopDog dog = () -> System.out.println("lambda");
              dog.shopping();
          }
      }

      interface ShopDog{
          public void shopping();
      }

      class Me implements ShopDog{

          @Override
          public void shopping() {
              System.out.println("买狗");
          }
      }

      class DaiGou implements ShopDog{
          private ShopDog target;

          public  DaiGou(ShopDog target){
              this.target = target;
          }

          @Override
          public void shopping() {
              before();
              this.target.shopping();
              after();
          }

          private void before() {
              System.out.println("知名代购公司");
          }
          private void after() {
              System.out.println("收尾款");
          }
      }
      ```
3. 线程状态

   1. 停止

      > 建议线程正常停止——>利用次数，不建议死循环
      >
      > 建议使用标志位——>设置一个标志位
      >
      > 不要使用stop或者destroy等过时或者JDK不建议使用的方法

      ```java
      public class TestStop implements Runnable {
          private boolean flag = true;

          @Override
          public void run() {
              while(flag){
                  System.out.println("线程进行中。。。");
              }
          }

          public void stop(){
              this.flag = false;
          }

          public static void main(String[] args) {
              TestStop testStop = new TestStop();
              new Thread(testStop).start();

              for (int i = 0; i < 1000; i++) {
                  System.out.println("main"+i);
                  if(i==900){
                      testStop.stop();
                      System.out.println("线程结束");
                  }
              }
          }
      }
      ```
   2. 休眠

      ```java
      public static void main(String[] args) throws InterruptedException {
      //        daojishi();
              shijian();
          }

          public static void daojishi() throws InterruptedException {
              int flag = 10;

              while(true){
                  if(flag==0){
                      System.out.println("结束");
                      break;
                  }
                  Thread.sleep(1000);
                  System.out.println(flag--);
              }
          }

          public static void shijian() throws InterruptedException {
              Date date = new Date(System.currentTimeMillis());
              while(true){
                  Thread.sleep(1000);
                  SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
                  String s = dateFormat.format(date);
                  System.out.println(s);
                  date = new Date(System.currentTimeMillis());
              }


          }
      ```
   3. 礼让

      ```java
      public class TestYield implements Runnable {
          @Override
          public void run() {
              System.out.println("进程开始");
              Thread.yield();
              System.out.println("进程结束");
          }

          public static void main(String[] args) {


              Thread thread = new Thread(new TestYield(),"李明");
              Thread thread1 = new Thread(new TestYield(),"老师");

              thread.start();
              thread1.start();
          }
      }
      ```
   4. 插队

      ```java
      public class TestJoin implements Runnable {
          @Override
          public void run() {
              for (int i = 0; i < 1000; i++) {
                  System.out.println("vip线程。。。。。"+i);
              }
          }


          public static void main(String[] args) throws InterruptedException {
              TestJoin testJoin = new TestJoin();
              Thread thread = new Thread(testJoin);
              thread.start();

              for (int i = 0; i < 500; i++) {
                  if(i==200){
                      thread.join();
                  }
                  System.out.println("main线程....."+i);
              }


          }
      }
      ```
   5. 线程状态

      ```java
      public static void main(String[] args) {
              Thread thread = new Thread(() -> {
                  for (int i = 0; i < 5; i++) {
                      try {
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
              });

              Thread.State state = thread.getState();
              System.out.println(state); //NEW
        
              thread.start();
              state = thread.getState();
              System.out.println(state);//RUNNABLE

              while (state!=Thread.State.TERMINATED){
                  try {
                      Thread.sleep(10);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }

                  state = thread.getState();
                  System.out.println(state); //TIMED_WAITING
              }
      //TERMINATED
          }
      ```
   6. 优先级

      ```java
      public class TestPriority {
          public static void main(String[] args) {

              System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());

              MyThreads myThreads = new MyThreads();

              Thread thread = new Thread(myThreads);
              Thread thread1 = new Thread(myThreads);
              Thread thread2 = new Thread(myThreads);

              thread1.setPriority(8);
              thread.start();

              thread1.setPriority(1);
              thread1.start();

              thread2.setPriority(Thread.MAX_PRIORITY);
              thread2.start();
          }

      }

      class MyThreads implements Runnable{
          @Override
          public void run() {
              System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
          }
      }
      ```